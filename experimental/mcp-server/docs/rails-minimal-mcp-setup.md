# Rails Minimal MCP Server Setup

**Status**: investigating

## Problem & Solution

**Current Issue:** Need minimal Rails setup for ORC Task Management with existing MCP gems
**Solution:** Use FastMCP gem with Rails API-only setup for clean, generator-based MCP server

## Recommended Stack: FastMCP + Rails API

### Why FastMCP over rails-mcp-server:
- âœ… **Rails Generator**: `rails generate fast_mcp:install` 
- âœ… **Clean Tool Architecture**: Simple class-based tools with validation
- âœ… **Multiple Transports**: STDIO and HTTP/SSE support
- âœ… **Dry-Schema Validation**: Built-in argument validation
- âœ… **Rails-Native**: Works seamlessly with Rails patterns

### Rails API-Only Setup
```bash
# Create minimal Rails API
rails new orc-tasks --api --database=sqlite3 --skip-action-mailer --skip-action-mailbox --skip-action-text --skip-active-job --skip-action-cable

cd orc-tasks
bundle add fast-mcp
bin/rails generate fast_mcp:install
```

## Project Structure

```
orc-tasks/
â”œâ”€â”€ Gemfile
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ application.rb           # API-only configuration
â”‚   â”œâ”€â”€ database.yml            # SQLite setup
â”‚   â””â”€â”€ routes.rb               # MCP routes
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ task.rb
â”‚   â”‚   â”œâ”€â”€ worktree.rb
â”‚   â”‚   â””â”€â”€ task_history.rb
â”‚   â”œâ”€â”€ tools/                  # FastMCP tools (generated)
â”‚   â”‚   â”œâ”€â”€ application_tool.rb
â”‚   â”‚   â”œâ”€â”€ create_task_tool.rb
â”‚   â”‚   â”œâ”€â”€ get_my_tasks_tool.rb
â”‚   â”‚   â”œâ”€â”€ update_task_tool.rb
â”‚   â”‚   â””â”€â”€ list_tasks_tool.rb
â”‚   â”œâ”€â”€ resources/              # FastMCP resources (generated)
â”‚   â”‚   â””â”€â”€ application_resource.rb
â”‚   â””â”€â”€ services/
â”‚       â”œâ”€â”€ context_detector.rb
â”‚       â””â”€â”€ task_coordinator.rb
â”œâ”€â”€ db/
â”‚   â”œâ”€â”€ migrate/
â”‚   â”‚   â””â”€â”€ 001_create_tasks.rb
â”‚   â””â”€â”€ schema.rb
â””â”€â”€ config.ru                  # Rack configuration
```

## FastMCP Tools Implementation

### Base Application Tool
```ruby
# app/tools/application_tool.rb (generated by FastMCP)
class ApplicationTool < FastMcp::Tool
  protected

  def current_context
    @current_context ||= ContextDetector.new
  end

  def task_coordinator
    @task_coordinator ||= TaskCoordinator.new
  end
end
```

### Create Task Tool (Orchestrator Context)
```ruby
# app/tools/create_task_tool.rb
class CreateTaskTool < ApplicationTool
  description "Create new task for investigation (orchestrator context)"

  arguments do
    required(:title).filled(:string).description("Task title")
    optional(:description).filled(:string).description("Detailed task description") 
    required(:worktree).filled(:string).description("Target worktree name")
    optional(:priority).filled(:string, included_in?: %w[low medium high]).description("Task priority")
    optional(:repository).filled(:string).description("Repository name")
    optional(:context).hash.description("Additional context (GitHub issue, files, etc.)")
  end

  def call(title:, worktree:, description: nil, priority: 'medium', repository: nil, context: {})
    task = Task.create!(
      title: title,
      description: description,
      worktree: worktree,
      priority: priority,
      repository: repository,
      status: 'investigating',
      created_by: 'orchestrator',
      context: context.to_json
    )

    {
      success: true,
      task: task.as_json,
      message: "âœ… Created task '#{title}' for #{worktree}"
    }
  rescue => e
    {
      success: false,
      error: e.message
    }
  end
end
```

### Get My Tasks Tool (Implementation Context)
```ruby
# app/tools/get_my_tasks_tool.rb
class GetMyTasksTool < ApplicationTool
  description "Get tasks for current worktree context (implementation agent)"

  arguments do
    optional(:status).filled(:string, included_in?: %w[investigating in_progress blocked completed])
      .description("Filter by task status")
  end

  def call(status: nil)
    worktree = current_context.current_worktree
    
    return {success: false, error: "No worktree context detected"} unless worktree

    tasks = Task.where(worktree: worktree)
    tasks = tasks.where(status: status) if status

    {
      success: true,
      worktree: worktree,
      tasks: tasks.map(&:as_json),
      message: format_tasks_summary(tasks)
    }
  end

  private

  def format_tasks_summary(tasks)
    return "No tasks found for current worktree." if tasks.empty?
    
    tasks.map do |task|
      status_emoji = {
        'investigating' => 'ðŸ”',
        'in_progress' => 'âš¡', 
        'blocked' => 'ðŸš«',
        'completed' => 'âœ…'
      }[task.status] || 'ðŸ“‹'
      
      "#{status_emoji} **#{task.title}** (#{task.priority} priority)\n" +
      "   Status: #{task.status}\n" +
      "   #{task.description || 'No description'}"
    end.join("\n\n")
  end
end
```

### Update Task Tool
```ruby
# app/tools/update_task_tool.rb
class UpdateTaskTool < ApplicationTool
  description "Update task status and add progress notes"

  arguments do
    required(:task_id).filled(:integer).description("Task ID to update")
    required(:status).filled(:string, included_in?: %w[investigating in_progress blocked completed])
      .description("New task status")
    optional(:notes).filled(:string).description("Progress notes or comments")
  end

  def call(task_id:, status:, notes: nil)
    task = Task.find(task_id)
    
    old_status = task.status
    task.update!(status: status, updated_at: Time.current)

    # Add history entry
    if notes.present?
      TaskHistory.create!(
        task_id: task.id,
        action: "status_change",
        notes: "#{old_status} â†’ #{status}: #{notes}",
        agent_id: current_context.agent_id
      )
    end

    {
      success: true,
      task: task.as_json,
      message: "âœ… Updated '#{task.title}' from #{old_status} to #{status}"
    }
  rescue ActiveRecord::RecordNotFound
    {success: false, error: "Task not found"}
  rescue => e
    {success: false, error: e.message}
  end
end
```

## Rails Models

### Task Model
```ruby
# app/models/task.rb
class Task < ApplicationRecord
  validates :title, presence: true
  validates :worktree, presence: true
  validates :status, inclusion: { in: %w[investigating in_progress blocked completed] }
  validates :priority, inclusion: { in: %w[low medium high] }

  has_many :task_histories, dependent: :destroy

  scope :for_worktree, ->(worktree) { where(worktree: worktree) }
  scope :by_status, ->(status) { where(status: status) }

  def context_hash
    return {} unless context.present?
    JSON.parse(context)
  rescue JSON::ParserError
    {}
  end
end
```

### Task History Model
```ruby
# app/models/task_history.rb
class TaskHistory < ApplicationRecord
  belongs_to :task
  
  validates :action, presence: true
  validates :agent_id, presence: true
end
```

## Database Migration
```ruby
# db/migrate/001_create_tasks.rb
class CreateTasks < ActiveRecord::Migration[8.0]
  def change
    create_table :tasks do |t|
      t.string :title, null: false
      t.text :description
      t.string :status, null: false, default: 'investigating'
      t.string :priority, null: false, default: 'medium'  
      t.string :worktree, null: false
      t.string :repository
      t.string :branch
      t.string :assigned_agent
      t.string :created_by
      t.text :context # JSON string
      t.timestamps
    end

    add_index :tasks, :status
    add_index :tasks, :worktree
    add_index :tasks, [:worktree, :status]

    create_table :task_histories do |t|
      t.references :task, null: false, foreign_key: true
      t.string :agent_id, null: false
      t.string :action, null: false
      t.text :notes
      t.timestamps
    end
  end
end
```

## Context Detection Service
```ruby
# app/services/context_detector.rb
class ContextDetector
  def current_worktree
    pwd = ENV['PWD'] || Dir.pwd
    return nil unless pwd.include?('/worktrees/')
    File.basename(pwd)
  end

  def current_repository
    current_worktree&.split('-')&.last
  end

  def current_branch
    return nil unless in_worktree?
    `git branch --show-current`.strip rescue nil
  end

  def in_worktree?
    !current_worktree.nil?
  end

  def in_orchestrator_context?
    pwd = ENV['PWD'] || Dir.pwd
    pwd.include?('/orc')
  end

  def agent_id
    if in_orchestrator_context?
      'orchestrator'
    else
      "implementer_#{current_worktree}"
    end
  end
end
```

## Rails Configuration

### API-Only Application
```ruby
# config/application.rb
require_relative "boot"

require "rails"
require "active_model/railtie"
require "active_record/railtie"
require "action_controller/railtie"

module OrcTasks
  class Application < Rails::Application
    config.load_defaults 8.0
    config.api_only = true
    
    # FastMCP configuration
    config.fast_mcp.default_transport = :sse
    config.fast_mcp.port = 6970
  end
end
```

### Routes
```ruby
# config/routes.rb
Rails.application.routes.draw do
  # FastMCP automatically adds these routes:
  # GET  /mcp/sse     (Server-Sent Events)
  # POST /mcp/tools   (Tool calls)
  
  # Health check
  get '/health', to: proc { [200, {}, ['OK']] }
end
```

## Development Workflow

### Setup Commands
```bash
# Create and setup
rails new orc-tasks --api --database=sqlite3 --minimal
cd orc-tasks
bundle add fast-mcp
bin/rails generate fast_mcp:install
bin/rails db:migrate

# Start server (SSE mode on port 6970)
bin/rails server -p 6970
```

### MCP Client Configuration
```json
// ~/.claude.json
{
  "mcpServers": {
    "orc-tasks": {
      "type": "sse",
      "url": "http://localhost:6970/mcp/sse"
    }
  }
}
```

## Advantages of Rails + FastMCP

1. **Generator Magic**: `rails generate fast_mcp:install` sets everything up
2. **Rails Conventions**: Familiar ActiveRecord, migrations, validations
3. **Clean Tools**: Class-based tools with built-in validation
4. **Multiple Transports**: STDIO and HTTP/SSE support
5. **Testing**: Full Rails testing stack (RSpec/Minitest)
6. **Development**: Rails console, generators, rake tasks

This gives us the Rails ecosystem you love with minimal overhead and excellent MCP integration!